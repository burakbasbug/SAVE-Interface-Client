<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>SAVE Simulation Interface</title>
    <link rel="stylesheet" type="text/css" href="assets/semantic.min.css" />
    <script src="assets/jquery-3.4.1.min.js"></script>
    <script src="assets/semantic.min.js"></script>
    <script src="assets/bluebird.min.js"></script>
    <script src="assets/lodash.min.js"></script>
  </head>
  <body>
    <!--  https://semantic-ui.com/introduction/getting-started.html-->
    <div>
      <button
        class="large ui button triggerSet"
        id="runOnceButton"
        onclick="runOnce()"
      >
        RUN ONCE
      </button>

      <div class="ui left action input" id="runStepsGroup">
        <button
          class="ui labeled icon button triggerSet"
          id="runSteps_Button"
          onclick="runSteps()"
        >
          <i class="play icon"></i>
          RUN STEPS
        </button>

        <input
          type="number"
          class="triggerSet"
          value="3"
          style="width: 7rem;"
          min="1"
          id="runSteps_Input"
        />
      </div>
      <button
        class="large ui button"
        id="resetButton"
        onclick="stop()"
        disabled
      >
        STOP
      </button>
    </div>
    <iframe
      src="http://localhost:5601"
      style="width: 100%; height: 100%;"
    ></iframe>
    <script>
      /* CONSTANTS */
      let STATE_SIMULATION_IS_RUNNING = false;
      const bluebird = Promise.noConflict();
      const resetButton = $('#resetButton');
      const runOnceButton = $('#runOnceButton');
      const runSteps_Button = $('#runSteps_Button');
      const runSteps_Input = $('#runSteps_Input');
      const triggerSet = $('.triggerSet');
      const serverUrl = 'http://localhost:3000';
      const MQTT_FAILED_MSG = 'MQTT NOT CONNECTED';
      initialCheck();

      async function initialCheck() {
        resetButton.attr('disabled', false);
        const { simulationCycleRunning, mqttConnected } = await getStatus();
        if (mqttConnected) {
          if (simulationCycleRunning) {
            alert('Last simulation cycle is not completed.');
            // await runOnce();
          }
        } else {
          alert('No MQTT Connection');
        }
      }

      function resetPanel() {
        STATE_SIMULATION_IS_RUNNING = false;
        triggerSet.attr('disabled', false);
        resetButton.attr('disabled', true);
      }

      function disableTriggers() {
        triggerSet.attr('disabled', true);
      }

      /**
       * sadece bir HTTP requestini fetch ile gönderen fonksiyon
       * @returns {Promise<void>}
       */
      async function getStatus() {
        const url = serverUrl + '/simulation/status';
        const resp = await fetch(url);
        if (resp.ok) {
          const result = await resp.json();
          console.log(result);
          return result;
        }
        console.error(resp.status);
        return bluebird.reject(resp.status + ' - ' + resp.statusText);
      }

      async function trigger() {
        const resp = await fetch(serverUrl + '/simulation/trigger', {
          method: 'POST',
        });

        if (resp.ok) {
          return bluebird.resolve();
        }
        if (resp.status === 429) {
          console.error('Simulator is already running!');
          return bluebird.resolve('Too many requests!');
        }
        return bluebird.reject(resp.status + ' - ' + resp.statusText);
      }

      /**
       * getStatus ile tekrar tekrar req göndererek cycle'in bitmesini bekler
       * bluebird.delay
       * saniyede 2 kere req
       * @returns {Promise<void>}
       */
      async function waitUntilCycleDone() {
        while (true) {
          await bluebird.delay(1500);
          const { simulationCycleRunning, mqttConnected } = await getStatus();
          if (!mqttConnected) {
            return bluebird.reject(MQTT_FAILED_MSG);
          }
          if (!simulationCycleRunning) {
            break;
          }
        }
        return bluebird.resolve();
      }

      async function runOnce() {
        try {
          STATE_SIMULATION_IS_RUNNING = true;
          disableTriggers();
          resetButton.attr('disabled', true);
          await trigger();
          await waitUntilCycleDone();
        } catch (e) {
          console.error(e);
          runOnceButton.transition({
            animation: 'shake',
            duration: 800,
          });
          await bluebird.delay(800);
        } finally {
          resetPanel();
        }
      }

      async function runSteps() {
        try {
          STATE_SIMULATION_IS_RUNNING = true;
          disableTriggers();
          resetButton.attr('disabled', false);
          let counter = parseInt(runSteps_Input.val());
          while (counter && counter > 0 && STATE_SIMULATION_IS_RUNNING) {
            await trigger();
            await waitUntilCycleDone();
            counter--;
            runSteps_Input.val(counter);
          }
        } catch (e) {
          console.error(e);
          runSteps_Button.transition({
            animation: 'shake',
            duration: 800,
          });
          await bluebird.delay(800);
        } finally {
          resetPanel();
        }
      }

      function stop() {
        STATE_SIMULATION_IS_RUNNING = false;
      }
    </script>
  </body>
</html>
